// prisma/schema.prisma
// ================ Generador y datasource ================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  // En producción (Vercel) usas el Pooler en DATABASE_URL
  url       = env("DATABASE_URL")
  // Para introspección/migraciones locales, usa la directa:
  directUrl = env("DIRECT_URL")
}

// ====================== Enums ===========================
// OJO: Prisma no admite nombres de enum como "_1" directamente.
// Por eso usamos nombres "bonitos" y los mapeamos a los valores reales de la BD.
enum Sign {
  ONE @map("_1")
  X
  TWO @map("_2")

  // Si en tu BD el enum se llama "Sign", deja esta línea.
  // Si se llama distinto, cámbialo o elimínalo.
  @@map("Sign")
}

// (Opcional si usas lista blanca con roles simples)
enum AllowedRole {
  admin
  player
}

// (Opcional si decides usar estado de jornada)
enum MatchdayStatus {
  OPEN
  CLOSED
  SETTLED
}

// ====================== Modelos =========================

// Usuario interno (para asociar picks a un email)
model User {
  id          String      @id @default(uuid()) @db.Uuid
  email       String      @unique @db.Citext
  displayName String
  role        AllowedRole @default(player)
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())

  predictions Prediction[]
  exemptions  Exemption[]
}

// Equipo
model Team {
  id           Int     @id @default(autoincrement())
  name         String
  shortName    String?
  isUnionistas Boolean @default(false)

  homeMatches Match[] @relation("HomeTeam")
  awayMatches Match[] @relation("AwayTeam")
}

// Jornada
model Matchday {
  id        Int             @id @default(autoincrement())
  number    Int
  season    String
  startsAt  DateTime
  status    MatchdayStatus?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  matches    Match[]
  // ✅ IMPORTANTE: back-relation para resolver el error que tenías
  exemptions Exemption[]
}

// Partido
model Match {
  id         Int      @id @default(autoincrement())
  matchdayId Int
  homeTeamId Int
  awayTeamId Int
  startsAt   DateTime
  result     Sign?

  matchday    Matchday     @relation(fields: [matchdayId], references: [id], onDelete: Cascade)
  homeTeam    Team         @relation("HomeTeam", fields: [homeTeamId], references: [id])
  awayTeam    Team         @relation("AwayTeam", fields: [awayTeamId], references: [id])
  predictions Prediction[]

  @@index([matchdayId])
  @@index([homeTeamId])
  @@index([awayTeamId])
}

// Predicción de un usuario para un partido
model Prediction {
  id        Int      @id @default(autoincrement())
  userId    String   @db.Uuid
  matchId   Int
  predSign  Sign
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([userId, matchId]) // un pick por usuario y partido
}

// Exención de pago tras pleno, etc. (1 por jornada/usuario)
model Exemption {
  id         Int      @id @default(autoincrement())
  userId     String   @db.Uuid
  matchdayId Int
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchday Matchday @relation(fields: [matchdayId], references: [id], onDelete: Cascade)

  @@unique([userId, matchdayId])
}

// ================= Lista blanca de emails =================
// (Si la usas para controlar quién entra a la app)
model AllowedEmail {
  email     String      @id @db.Citext
  role      AllowedRole @default(player)
  isActive  Boolean     @default(true) @map("is_active")
  createdAt DateTime    @default(now()) @map("created_at")

  @@map("AllowedEmail")
}

model PredictionScore {
  predictionId Int        @id
  points       Int        @default(0)

  prediction   Prediction @relation(fields: [predictionId], references: [id], onDelete: Cascade)

  @@map("PredictionScore")
}
